### Exercise 1
> 参考：
> [1] [https://blog.csdn.net/GOGOmusic/article/details/80223371](https://blog.csdn.net/GOGOmusic/article/details/80223371)
> [2] [https://blog.csdn.net/k346k346/article/details/50072445](https://blog.csdn.net/k346k346/article/details/50072445)

计算机中，数值一律采用补码来表示/存储，正数的补码就是其本身，负数的补码为其反码加一（反码为原码除去其最高位取反）。<br />执行完`a++`之后，`a`为128，补码为`1000 0000`。若要将`a`以整数打印，需要将char类型转换为int类型，涉及数据类型宽度的扩展问题。<br />当char类型转换到int类型时，C标准中有如下规则：<br />（1）短数据类型转换到长数据类型：

1. 若要扩展的短数据类型为有符号数，则进行符号扩展，即短数据类型的符号位填充到长数据类型的高字节位（即比短数据类型多出的那一部分），保证扩展后的数值大小不变；
2. 若要扩展的短数据类型为无符号数，则进行零扩展，即用零来填充长数据类型的高字节位。

（2）长数据类型缩减为短数据类型：

1. 如果长数据类型的高字节全为 1 或全为 0，则会直接截取低字节赋给短数据类型；
2. 如果长数据类型的高字节不全为 1 或不全为 0，则转换就会发生错误。

（3）同一长度的数据类型中有符号数与无符号数的相互转化：<br />直接将内存中的数据赋给要转化的类型，数值大小则会发生变化，因为以不同类型解释同一段内存数据会得到不同的数值。比如一个字节中存放的数据是`1111 1111`，以unsigned char来解释是 255，以char来解释是-1。

根据以上规则，128的补码为`1000 0000`，且为有符号数（第一位为符号位），进行符号扩展。扩展为int类型后，变量中储存的4个字节的数据为：<br />`11111111 11111111 11111111 10000000`<br />按照int类型来解释这4个字节的数据，第一位符号位为-1，表示负数，且这里是补码。对负数的补码再次取补，可以得到负数的原码：<br />`10000000 00000000 00000000 10000000`<br />即为-128。

同理，`b++`后的补码为`0000 0000`，无符号数按0来填充，得到的int类型数据为：<br />`00000000 00000000 00000000 00000000`<br />为0。

`c--`后的补码为`1111 1111`，无符号数按0来填充，得到的int类型数据为：<br />`00000000 00000000 00000000 11111111`<br />为255。

### Exercise 3
浮点数存在量化误差，本例中的`0.1`是无法精确表示的。

### Exercise 4
19.99+21.99=41.98，但`a`是int类型，将41.98赋值给`a`会自动舍去小数部分，则`a`为41.<br />同理，对19.99和21.99进行类型转换，直接舍去小数部分，得到19和21，则`b`为40。<br />对于`c`，被除数和除数均为整数，则结果也为整数，2.875舍去小数部分为2，则`c`为2。<br />对于`d`，除数8.0为double类型，则结果也为double类型，为2.875。

### Exercise 5
auto类型定义的变量在赋值之后，变量的类型就被确定下来，不会发生改变。因此后续的操作都会把结果转换成int类型。

